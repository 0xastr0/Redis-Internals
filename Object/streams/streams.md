# streams

# contents

* [prerequisites](#prerequisites)
* [related file](#related-file)
* [memory layout](#memory-layout)
* [internal](#internal)
	* [streams](#streams)
	* [listpack](#listpack)
		* [xadd](#xadd)
		* [xdel](#xdel)
	* [rax](#rax)
* [read more](#read-more)

# prerequisites

* [rax](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/rax/rax.md)(a redis implementation [radix tree](https://redis.io/topics/streams-intro))
* [redis listpack implementation](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/listpack/listpack.md)


# related file
* redis/src/stream.h
* redis/src/t_stream.c
* redis/src/rax.h
* redis/src/rax.c
* redis/src/listpack.h
* redis/src/listpack.c

# overview

Redis `streams` is introduced in version >= 5.0, it's a MQ like structure, it models a log data structure in a more abstract way, For more overview detail please refer to [Introduction to Redis Streams](https://redis.io/topics/streams-intro)

The block in red in the basic layout of `streams` structure

![streams](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/streams/streams.png)

# internal

`stremas` is a new and special type, the `object encoding` returns `unknown` but it actually has a type named `OBJ_STREAM`

    127.0.0.1:6379> xadd mystream * key1 128
    "1576480551233-0"
    127.0.0.1:6379> object encoding mystream
    "unknown"

Together with [rax](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/rax/rax.md) and [listpack](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/listpack/listpack.md) in [prerequisites](#prerequisites), there're totally 3 parts in `mystream`

The first part is `robj`, every redis object will have this basic part to indicate that the actual type, encoding and location of the target object stored in `ptr` field

The second part is `rax`, it's used for storing the `stream ID`

The third part is `listpack`, every key node in the `rax` stores the according `keys` and `values` in the `listpack` structure

![mystream](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/streams/mystream.png)

## streams

If we add a new value to the same key again

    127.0.0.1:6379> xadd mystream * key1 val1
    "1576486352510-0"

![mystream2](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/streams/mystream2.png)

We can see that the `stream` structure is used for storing data, `rax` points to a radix tree which stores first unread ID as entry and the `keys` and `values` in the according `listpack` associated with key node in `rax`

`length` indicate how many elements are currently stored inside the `stream`(actually number of all key value pair inside all the `listpack` in all key node in the `rax`)

`last_id` stores the latest `ID` generated by `stream` automatically or specific by caller

`cgroups` stores the information of `consumer groups` in `rax` data structure

## listpack

### xadd

	int streamAppendItem(stream *s, robj **argv, int64_t numfields, streamID *added_id, streamID *use_id) {
        raxIterator ri;
        raxStart(&ri,s->rax);
        raxSeek(&ri,"$",NULL,0);
        /* ... */
        /* Get a reference to the tail node listpack. */
        if (raxNext(&ri)) {
            lp = ri.data;
            lp_bytes = lpBytes(lp);
        }
        /* ... */
        /* The master entry is composed like in the following example:
         *
         * +-------+---------+------------+---------+--/--+---------+---------+-+
         * | count | deleted | num-fields | field_1 | field_2 | ... | field_N |0|
         * +-------+---------+------------+---------+--/--+---------+---------+-+
         * /
        if (lp != NULL) {
            if (server.stream_node_max_bytes &&
                lp_bytes > server.stream_node_max_bytes)
            {
                lp = NULL;
            } else if (server.stream_node_max_entries) {
                int64_t count = lpGetInteger(lpFirst(lp));
                if (count > server.stream_node_max_entries) lp = NULL;
            }
        }
        /* ... */
    }

We can learn from the above source code that when you insert a new item into the `stream` object, it will find the last `listpack` object and keep inserting to this `listpack` until it's full(size exceed `stream-node-max-bytes`(4kb by default) or length exceed `stream-node-max-entries`(100 by default))

### xdel

If we delete the last entry

    127.0.0.1:6379> xdel mystream 1576486352510-0
    (integer) 1

![xdel](https://github.com/zpoint/Redis-Internals/blob/5.0/Object/streams/xdel.png)

The only difference is the first bit in the `flag` is set, and the first two entries of `listpack`, num items become one less and num deleted become one more

The following is part of the source code

    void streamIteratorRemoveEntry(streamIterator *si, streamID *current) {
        unsigned char *lp = si->lp;
        int64_t aux;

        /* We do not really delete the entry here. Instead we mark it as
         * deleted flagging it, and also incrementing the count of the
         * deleted entries in the listpack header.
         *
         * We start flagging: */
        int flags = lpGetInteger(si->lp_flags);
        flags |= STREAM_ITEM_FLAG_DELETED;
        lp = lpReplaceInteger(lp,&si->lp_flags,flags);

        /* Change the valid/deleted entries count in the master entry. */
        unsigned char *p = lpFirst(lp);
        aux = lpGetInteger(p);

        if (aux == 1) {
            /* If this is the last element in the listpack, we can remove the whole
             * node. */
            lpFree(lp);
            raxRemove(si->stream->rax,si->ri.key,si->ri.key_len,NULL);
        } else {
            /* In the base case we alter the counters of valid/deleted entries. */
            lp = lpReplaceInteger(lp,&p,aux-1);
            p = lpNext(lp,p); /* Seek deleted field. */
            aux = lpGetInteger(p);
            lp = lpReplaceInteger(lp,&p,aux+1);

            /* Update the listpack with the new pointer. */
            if (si->lp != lp)
                raxInsert(si->stream->rax,si->ri.key,si->ri.key_len,lp,NULL);
        }

        /* Update the number of entries counter. */
        si->stream->length--;
        /* ... */
    }



## rax

# read more
* [Introduction to Redis Streams](https://redis.io/topics/streams-intro)
